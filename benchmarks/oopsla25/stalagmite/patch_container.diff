diff --git a/Dockerfile b/Dockerfile
old mode 100644
new mode 100755
index 7bb5a36..34b8aa4
--- a/Dockerfile
+++ b/Dockerfile
@@ -94,7 +94,7 @@ RUN cd /staminag/klee && \
 # Run grammar mining
 CMD cp -rT /staminag/data_backup/ /staminag/data/ && \
 	cd /staminag/eval && \
-    ./tmux_mine_all.sh
+    ./run_eval.sh
 
 
 # => Data is available at /data/paper/accuracy/csv
diff --git a/eval/eval.py b/eval/eval.py
index 13582ca..2cc266e 100644
--- a/eval/eval.py
+++ b/eval/eval.py
@@ -99,7 +99,7 @@ def data_accuracy(subject: Subject):
             precisions.append(precision)
             recall = compute_recall(subject.put, golden_grammar, grammar, max_depth, config.cnt_inputs)
             recalls.append(recall)
-            f1 = 2*(precision*recall)/(precision+recall)
+            f1 = 2*(precision*recall)/(precision+recall) if (precision+recall) > 0 else 0
             f1s.append(f1)
 
         with open(output_csv_file, "a") as f:
diff --git a/eval/precision.py b/eval/precision.py
old mode 100644
new mode 100755
index 607405a..7e1da24
--- a/eval/precision.py
+++ b/eval/precision.py
@@ -18,7 +18,8 @@ def _compute_precision(put, grammar, max_depth: int, count: int):
     inputs = set()
     valid = []
     invalid = []
-    while len(inputs) < count:
+    rep_inps = 0
+    while len(inputs) < count and rep_inps < count:
         signal.signal(signal.SIGALRM, fuzz_alarm_handler)
         signal.alarm(1)
         try:
@@ -37,17 +38,19 @@ def _compute_precision(put, grammar, max_depth: int, count: int):
                 case False:
                     invalid.append(inp)
                 case None:
-                    continue
+                    invalid.append(inp)
                 case _:
                     assert False, "unmatched"
             print(f"Inp ({len(inputs)}/{count} {repr(inp)} is valid=", parsed)
             inputs.add(inp)
+        else:
+            rep_inps += 1
 
     print("invalid: ", invalid)
     print("valid: ", valid)
     print(f"Precision ({len(valid)}/{len(valid)+len(invalid)})")
     precision = len(valid)/(len(valid)+len(invalid))
-    assert count == len(valid)+len(invalid)
+    assert count == len(valid)+len(invalid) or rep_inps >= count
     return precision, valid
 
 def compute_precision(put, grammar, max_depth: int, count: int) -> float:
diff --git a/eval/recall.py b/eval/recall.py
old mode 100644
new mode 100755
index 19d0ee3..12ed69f
--- a/eval/recall.py
+++ b/eval/recall.py
@@ -14,13 +14,19 @@ def timeout_handler(signum, frame):
 def compute_recall(put, goldengrammar, minedgrammar, max_depth: int, count: int) -> float:
     f = LimitFuzzer(goldengrammar)
     inputs = set()
-    while len(inputs) < count:
+    rep_inps = 0
+    while len(inputs) < count and rep_inps < count:
         inp, _ = f.fuzz('<start>', max_depth=max_depth)
         print("recall -- generated inp: ", inp)
         if inp not in inputs:
             if put_can_parse(put, inp) == True:
                 inputs.add(inp)
                 print("inputs: ", len(inputs))
+            else:
+                print("WARNING: parser does not accept golden grammar input")
+                rep_inps += 1
+        else:
+            rep_inps += 1
 
     parser = P.IterativeEarleyParser(P.non_canonical(minedgrammar), start_symbol='<start>')
     valid = []
@@ -53,7 +59,7 @@ def compute_recall(put, goldengrammar, minedgrammar, max_depth: int, count: int)
     print("invalid: ", invalid)
     print("valid: ", valid)
     print(f"Recall ({len(valid)}/{len(valid)+len(invalid)})")
-    recall = len(valid)/(len(valid)+len(invalid))
+    recall = len(valid)/(len(valid)+len(invalid)) if len(valid)+len(invalid) > 0 else 0
     return recall
 
 def main():
diff --git a/generalize/reduce_overapproximation.py b/generalize/reduce_overapproximation.py
index bcb1823..42d0c37 100644
--- a/generalize/reduce_overapproximation.py
+++ b/generalize/reduce_overapproximation.py
@@ -227,7 +227,7 @@ def generate_and_classify_inputs(grammar, put, count):
     valid = set()
     invalid = set()
     i = 0
-    while i < count or len(valid) < config.min_count_valid:
+    while i < count or (len(valid) < config.min_count_valid and len(invalid) < 1):
         signal.signal(signal.SIGALRM, fuzz_alarm_handler)
         signal.alarm(1)
         try:
@@ -239,7 +239,8 @@ def generate_and_classify_inputs(grammar, put, count):
             signal.alarm(0)
 
         can_parse = put_can_parse(put, inp)
-        if can_parse == None: continue # core dumped, e.g. div-by-zero / semantic error
+        if can_parse == None: # core dumped, e.g. div-by-zero / semantic error
+            invalid.add(inp)
         elif can_parse == False:
             invalid.add(inp)
         else:
